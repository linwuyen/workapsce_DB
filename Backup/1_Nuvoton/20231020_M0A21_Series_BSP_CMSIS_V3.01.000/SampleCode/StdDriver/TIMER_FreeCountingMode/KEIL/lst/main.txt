; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\M0A21\Include -I..\..\..\..\Library\StdDriver\inc -I.\RTE\_TIMER_FreeCountingMode -IC:\Users\cody_chen\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\cody_chen\AppData\Local\Arm\Packs\Nuvoton\NuMicro_DFP\1.3.21\Device\M0A21\Include -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -D_RTE_ --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;47     
;;;48     void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  4c1d              LDR      r4,|L1.124|
000006  2216              MOVS     r2,#0x16
000008  2188              MOVS     r1,#0x88
                  |L1.10|
00000a  6020              STR      r0,[r4,#0]
00000c  6022              STR      r2,[r4,#0]
00000e  6021              STR      r1,[r4,#0]
000010  6823              LDR      r3,[r4,#0]
000012  2b00              CMP      r3,#0
000014  d0f9              BEQ      |L1.10|
;;;49     {
;;;50         /* Unlock protected registers */
;;;51         SYS_UnlockReg();
;;;52     
;;;53         /* Enable HIRC */
;;;54         CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
000016  2004              MOVS     r0,#4
000018  f7fffffe          BL       CLK_EnableXtalRC
;;;55     
;;;56         /* Waiting for HIRC clock ready */
;;;57         CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00001c  2010              MOVS     r0,#0x10
00001e  f7fffffe          BL       CLK_WaitClockReady
;;;58     
;;;59         /* Switch HCLK clock source to HIRC */
;;;60         CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
000022  2100              MOVS     r1,#0
000024  2007              MOVS     r0,#7
000026  f7fffffe          BL       CLK_SetHCLK
;;;61     
;;;62         /* Set both PCLK0 and PCLK1 as HCLK/2 */
;;;63         CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);
00002a  4915              LDR      r1,|L1.128|
00002c  2011              MOVS     r0,#0x11
00002e  6348              STR      r0,[r1,#0x34]
;;;64     
;;;65         /* Switch UART0 clock source to HIRC */
;;;66         CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HIRC, CLK_CLKDIV0_UART0(1));
000030  4d14              LDR      r5,|L1.132|
000032  2103              MOVS     r1,#3
000034  2200              MOVS     r2,#0
000036  0609              LSLS     r1,r1,#24
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       CLK_SetModuleClock
;;;67     
;;;68         /* Enable UART peripheral clock */
;;;69         CLK_EnableModuleClock(UART0_MODULE);
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       CLK_EnableModuleClock
;;;70     
;;;71         /* Enable IP clock */
;;;72         CLK_EnableModuleClock(TMR0_MODULE);
000044  4d10              LDR      r5,|L1.136|
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       CLK_EnableModuleClock
;;;73     
;;;74         /* Select IP clock source */
;;;75         CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_PCLK0, 0);
00004c  2101              MOVS     r1,#1
00004e  2200              MOVS     r2,#0
000050  0249              LSLS     r1,r1,#9
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       CLK_SetModuleClock
;;;76     
;;;77         /* Update System Core Clock */
;;;78         /* User can use SystemCoreClockUpdate() to calculate PllClock, SystemCoreClock and CycylesPerUs automatically. */
;;;79         SystemCoreClockUpdate();
000058  f7fffffe          BL       SystemCoreClockUpdate
;;;80     
;;;81         /*----------------------------------------------------------------------*/
;;;82         /* Init I/O Multi-function                                              */
;;;83         /*----------------------------------------------------------------------*/
;;;84         /* Set PB multi-function pins for UART0 RXD=PB.6 and TXD=PB.4 */
;;;85         SYS->GPB_MFP1 = (SYS->GPB_MFP1 & ~(SYS_GPB_MFP1_PB4MFP_Msk | SYS_GPB_MFP1_PB6MFP_Msk)) |
00005c  4807              LDR      r0,|L1.124|
00005e  38c0              SUBS     r0,r0,#0xc0
000060  6841              LDR      r1,[r0,#4]
000062  4a0a              LDR      r2,|L1.140|
000064  4011              ANDS     r1,r1,r2
000066  4a0a              LDR      r2,|L1.144|
000068  1889              ADDS     r1,r1,r2
00006a  6041              STR      r1,[r0,#4]
;;;86                         (SYS_GPB_MFP1_PB4MFP_UART0_TXD | SYS_GPB_MFP1_PB6MFP_UART0_RXD);
;;;87     
;;;88         /* Set Timer 0 capture pin */
;;;89         SYS->GPC_MFP1 = (SYS->GPC_MFP1 & ~(SYS_GPC_MFP1_PC4MFP_Msk)) |
00006c  6941              LDR      r1,[r0,#0x14]
00006e  0a09              LSRS     r1,r1,#8
000070  0209              LSLS     r1,r1,#8
000072  311a              ADDS     r1,r1,#0x1a
000074  6141              STR      r1,[r0,#0x14]
000076  2000              MOVS     r0,#0
000078  6020              STR      r0,[r4,#0]
;;;90                         (SYS_GPC_MFP1_PC4MFP_TM0_EXT);
;;;91     
;;;92         /* Lock protected registers */
;;;93         SYS_LockReg();
;;;94     }
00007a  bd70              POP      {r4-r6,pc}
;;;95     
                          ENDP

                  |L1.124|
                          DCD      0x40000100
                  |L1.128|
                          DCD      0x40000200
                  |L1.132|
                          DCD      0x5f803d10
                  |L1.136|
                          DCD      0x5e800002
                  |L1.140|
                          DCD      0xff00ff00
                  |L1.144|
                          DCD      0x00090008

                          AREA ||i.TMR0_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  TMR0_IRQHandler PROC
;;;14     
;;;15     void TMR0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
000002  4a10              LDR      r2,|L2.68|
000004  2301              MOVS     r3,#1
000006  6193              STR      r3,[r2,#0x18]
;;;16     {
;;;17         static int cnt = 0;
;;;18         static uint32_t t0, t1;
;;;19     
;;;20         TIMER_ClearCaptureIntFlag(TIMER0);
;;;21     
;;;22         if(cnt == 0)
000008  490f              LDR      r1,|L2.72|
00000a  6808              LDR      r0,[r1,#0]  ; cnt
00000c  2800              CMP      r0,#0
00000e  d004              BEQ      |L2.26|
;;;23         {
;;;24             t0 = TIMER_GetCaptureData(TIMER0);
;;;25             cnt++;
;;;26         }
;;;27         else if(cnt == 1)
000010  2801              CMP      r0,#1
000012  d006              BEQ      |L2.34|
;;;28         {
;;;29             t1 = TIMER_GetCaptureData(TIMER0);
;;;30             cnt++;
;;;31             if(t0 >= t1)
;;;32             {
;;;33                 /* over run, drop this data and do nothing */
;;;34             }
;;;35             else
;;;36             {
;;;37                 /* TIMER0 clock source = PCLK0 = HCLK / 2 = HIRC / 2 */
;;;38                 printf("Input frequency is %dHz\n", (__HIRC/2) / (t1 - t0));
;;;39             }
;;;40         }
;;;41         else
;;;42         {
;;;43             cnt = 0;
000014  2000              MOVS     r0,#0
000016  6008              STR      r0,[r1,#0]  ; cnt
;;;44         }
;;;45     }
000018  bd10              POP      {r4,pc}
                  |L2.26|
00001a  6910              LDR      r0,[r2,#0x10]
00001c  600b              STR      r3,[r1,#0]            ;25  ; cnt
00001e  6048              STR      r0,[r1,#4]            ;25  ; t0
                  |L2.32|
000020  bd10              POP      {r4,pc}
                  |L2.34|
000022  6910              LDR      r0,[r2,#0x10]
000024  2202              MOVS     r2,#2                 ;30
000026  600a              STR      r2,[r1,#0]            ;31  ; cnt
000028  6088              STR      r0,[r1,#8]            ;31  ; t1
00002a  6849              LDR      r1,[r1,#4]            ;31  ; t0
00002c  4281              CMP      r1,r0                 ;31
00002e  d2f7              BCS      |L2.32|
000030  1a41              SUBS     r1,r0,r1              ;38
000032  4806              LDR      r0,|L2.76|
000034  f7fffffe          BL       __aeabi_uidivmod
000038  4601              MOV      r1,r0                 ;38
00003a  a005              ADR      r0,|L2.80|
00003c  f7fffffe          BL       __2printf
000040  bd10              POP      {r4,pc}
;;;46     
                          ENDP

000042  0000              DCW      0x0000
                  |L2.68|
                          DCD      0x40050000
                  |L2.72|
                          DCD      ||.data||
                  |L2.76|
                          DCD      0x016e3600
                  |L2.80|
000050  496e7075          DCB      "Input frequency is %dHz\n",0
000054  74206672
000058  65717565
00005c  6e637920
000060  69732025
000064  64487a0a
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                  UART0_Init PROC
;;;98     /*----------------------------------------------------------------------*/
;;;99     void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;100    {
;;;101        /* Reset UART0 */
;;;102        SYS_ResetModule(UART0_RST);
000002  4804              LDR      r0,|L3.20|
000004  f7fffffe          BL       SYS_ResetModule
;;;103    
;;;104        /* Configure UART0 and set UART0 baud rate */
;;;105        UART_Open(UART0, 115200);
000008  21e1              MOVS     r1,#0xe1
00000a  0249              LSLS     r1,r1,#9
00000c  4802              LDR      r0,|L3.24|
00000e  f7fffffe          BL       UART_Open
;;;106    }
000012  bd10              POP      {r4,pc}
;;;107    
                          ENDP

                  |L3.20|
                          DCD      0x04000010
                  |L3.24|
                          DCD      0x40070000

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;107    
;;;108    int main(void)
000000  f7fffffe          BL       SYS_Init
;;;109    {
;;;110        int volatile i;
;;;111    
;;;112        /* Init System, IP clock and multi-function I/O. */
;;;113        SYS_Init();
;;;114    
;;;115        /* Init UART0 for printf */
;;;116        UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;117    
;;;118        printf("\nThis sample code demonstrate timer free counting mode.\n");
000008  a013              ADR      r0,|L4.88|
00000a  f7fffffe          BL       __2printf
;;;119        printf("Please connect input source with Timer 0 capture pin PC.4, press any key to continue\n");
00000e  4821              LDR      r0,|L4.148|
000010  f7fffffe          BL       __2printf
;;;120        getchar();
000014  4820              LDR      r0,|L4.152|
000016  f7fffffe          BL       getc
;;;121    
;;;122        /* Give a dummy target frequency here. Will over write capture resolution with macro */
;;;123        TIMER_Open(TIMER0, TIMER_PERIODIC_MODE, 1000000);
00001a  4c21              LDR      r4,|L4.160|
00001c  2101              MOVS     r1,#1
00001e  4a1f              LDR      r2,|L4.156|
000020  06c9              LSLS     r1,r1,#27
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       TIMER_Open
;;;124    
;;;125        /* Update prescale to set proper resolution. */
;;;126        TIMER_SET_PRESCALE_VALUE(TIMER0, 0);
000028  6820              LDR      r0,[r4,#0]
00002a  0a00              LSRS     r0,r0,#8
00002c  0200              LSLS     r0,r0,#8
00002e  6020              STR      r0,[r4,#0]
;;;127    
;;;128        /* Set compare value as large as possible, so don't need to worry about counter overrun too frequently. */
;;;129        TIMER_SET_CMP_VALUE(TIMER0, TIMER_CMP_MAX_VALUE);
000030  481c              LDR      r0,|L4.164|
000032  6060              STR      r0,[r4,#4]
;;;130    
;;;131        /* Configure Timer 0 free counting mode, capture TDR value on rising edge */
;;;132        TIMER_EnableCapture(TIMER0, TIMER_CAPTURE_FREE_COUNTING_MODE, TIMER_CAPTURE_EVENT_RISING);
000034  2201              MOVS     r2,#1
000036  0312              LSLS     r2,r2,#12
000038  2100              MOVS     r1,#0
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       TIMER_EnableCapture
000040  6820              LDR      r0,[r4,#0]
000042  03a1              LSLS     r1,r4,#14
000044  4308              ORRS     r0,r0,r1
000046  6020              STR      r0,[r4,#0]
000048  6960              LDR      r0,[r4,#0x14]
00004a  2120              MOVS     r1,#0x20
00004c  4308              ORRS     r0,r0,r1
00004e  6160              STR      r0,[r4,#0x14]
000050  00c8              LSLS     r0,r1,#3
000052  4915              LDR      r1,|L4.168|
000054  6008              STR      r0,[r1,#0]
                  |L4.86|
;;;133    
;;;134        /* Start Timer 0 */
;;;135        TIMER_Start(TIMER0);
;;;136    
;;;137        /* Enable timer interrupt */
;;;138        TIMER_EnableCaptureInt(TIMER0);
;;;139        NVIC_EnableIRQ(TMR0_IRQn);
;;;140    
;;;141        while(1);
000056  e7fe              B        |L4.86|
;;;142    }
                          ENDP

                  |L4.88|
000058  0a546869          DCB      "\nThis sample code demonstrate timer free counting mode"
00005c  73207361
000060  6d706c65
000064  20636f64
000068  65206465
00006c  6d6f6e73
000070  74726174
000074  65207469
000078  6d657220
00007c  66726565
000080  20636f75
000084  6e74696e
000088  67206d6f
00008c  6465    
00008e  2e0a00            DCB      ".\n",0
000091  00                DCB      0
000092  00                DCB      0
000093  00                DCB      0
                  |L4.148|
                          DCD      ||.conststring||
                  |L4.152|
                          DCD      __stdin
                  |L4.156|
                          DCD      0x000f4240
                  |L4.160|
                          DCD      0x40050000
                  |L4.164|
                          DCD      0x00ffffff
                  |L4.168|
                          DCD      0xe000e100

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  506c6561          DCB      "Please connect input source with Timer 0 capture pin PC"
000004  73652063
000008  6f6e6e65
00000c  63742069
000010  6e707574
000014  20736f75
000018  72636520
00001c  77697468
000020  2054696d
000024  65722030
000028  20636170
00002c  74757265
000030  2070696e
000034  205043  
000037  2e342c20          DCB      ".4, press any key to continue\n",0
00003b  70726573
00003f  7320616e
000043  79206b65
000047  7920746f
00004b  20636f6e
00004f  74696e75
000053  650a00  

                          AREA ||.data||, DATA, ALIGN=2

                  ||cnt||
                          DCD      0x00000000
                  ||t0||
                          DCD      0x00000000
                  ||t1||
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_d50ddd2d____REV16|
#line 464 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_d50ddd2d____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_d50ddd2d____REVSH|
#line 479
|__asm___6_main_c_d50ddd2d____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
