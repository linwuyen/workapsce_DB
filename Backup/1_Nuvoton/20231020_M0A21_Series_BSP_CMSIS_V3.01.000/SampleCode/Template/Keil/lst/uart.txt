; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\uart.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\uart.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M0A21\Include -I..\..\..\Library\StdDriver\inc -I.\RTE\_Template -IC:\Users\cody_chen\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\cody_chen\AppData\Local\Arm\Packs\Nuvoton\NuMicro_DFP\1.3.21\Device\M0A21\Include -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -D_RTE_ --omf_browse=.\obj\uart.crf ..\..\..\Library\StdDriver\src\uart.c]
                          THUMB

                          AREA ||i.UART_ClearIntFlag||, CODE, READONLY, ALIGN=2

                  UART_ClearIntFlag PROC
;;;41     
;;;42     void UART_ClearIntFlag(UART_T *uart , uint32_t u32InterruptFlag)
000000  01ca              LSLS     r2,r1,#7
;;;43     {
000002  d502              BPL      |L1.10|
;;;44     
;;;45     
;;;46         if (u32InterruptFlag & UART_INTSTS_SWBEINT_Msk)   /* Clear Bit Error Detection Interrupt */
;;;47         {
;;;48             uart->INTSTS = UART_INTSTS_SWBEIF_Msk;
000004  2201              MOVS     r2,#1
000006  0412              LSLS     r2,r2,#16
000008  61c2              STR      r2,[r0,#0x1c]
                  |L1.10|
;;;49         }
;;;50     
;;;51         if (u32InterruptFlag & UART_INTSTS_RLSINT_Msk)   /* Clear Receive Line Status Interrupt */
00000a  054a              LSLS     r2,r1,#21
00000c  d503              BPL      |L1.22|
;;;52         {
;;;53             uart->FIFOSTS = UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk;
00000e  2270              MOVS     r2,#0x70
000010  6182              STR      r2,[r0,#0x18]
;;;54             uart->FIFOSTS = UART_FIFOSTS_ADDRDETF_Msk;
000012  2208              MOVS     r2,#8
000014  6182              STR      r2,[r0,#0x18]
                  |L1.22|
;;;55         }
;;;56     
;;;57         if (u32InterruptFlag & UART_INTSTS_MODEMINT_Msk)   /* Clear Modem Status Interrupt */
000016  050a              LSLS     r2,r1,#20
000018  d503              BPL      |L1.34|
;;;58         {
;;;59             uart->MODEMSTS |= UART_MODEMSTS_CTSDETF_Msk;
00001a  6942              LDR      r2,[r0,#0x14]
00001c  2301              MOVS     r3,#1
00001e  431a              ORRS     r2,r2,r3
000020  6142              STR      r2,[r0,#0x14]
                  |L1.34|
;;;60         }
;;;61     
;;;62         if (u32InterruptFlag & UART_INTSTS_BUFERRINT_Msk)   /* Clear Buffer Error Interrupt */
000022  048a              LSLS     r2,r1,#18
000024  d501              BPL      |L1.42|
;;;63         {
;;;64             uart->FIFOSTS = UART_FIFOSTS_RXOVIF_Msk | UART_FIFOSTS_TXOVIF_Msk;
000026  4a08              LDR      r2,|L1.72|
000028  6182              STR      r2,[r0,#0x18]
                  |L1.42|
;;;65         }
;;;66     
;;;67         if (u32InterruptFlag & UART_INTSTS_WKINT_Msk)   /* Clear Wake-up Interrupt */
00002a  044a              LSLS     r2,r1,#17
00002c  d504              BPL      |L1.56|
;;;68         {
;;;69             uart->LINWKCTL = UART_LINWKCTL_LINWKF_Msk;
00002e  2201              MOVS     r2,#1
000030  0752              LSLS     r2,r2,#29
000032  6502              STR      r2,[r0,#0x50]
;;;70             uart->WKSTS = UART_WKSTS_CTSWKF_Msk  | UART_WKSTS_DATWKF_Msk  |
000034  221f              MOVS     r2,#0x1f
000036  6442              STR      r2,[r0,#0x44]
                  |L1.56|
;;;71                           UART_WKSTS_RFRTWKF_Msk | UART_WKSTS_RS485WKF_Msk |
;;;72                           UART_WKSTS_TOUTWKF_Msk;
;;;73         }
;;;74     
;;;75         if(u32InterruptFlag & UART_INTSTS_LININT_Msk)       /* Clear LIN Bus Interrupt */
000038  0409              LSLS     r1,r1,#16
00003a  d503              BPL      |L1.68|
;;;76         {
;;;77             uart->INTSTS = UART_INTSTS_LINIF_Msk;
00003c  2180              MOVS     r1,#0x80
00003e  61c1              STR      r1,[r0,#0x1c]
;;;78             uart->LINSTS = UART_LINSTS_BITEF_Msk    | UART_LINSTS_BRKDETF_Msk  |
000040  4902              LDR      r1,|L1.76|
000042  6381              STR      r1,[r0,#0x38]
                  |L1.68|
;;;79                            UART_LINSTS_RTOUTF_Msk | UART_INTSTS_LINIF_Msk |        
;;;80                            UART_LINSTS_SLVSYNCF_Msk | UART_LINSTS_SLVIDPEF_Msk |
;;;81                            UART_LINSTS_SLVHEF_Msk   | UART_LINSTS_SLVHDETF_Msk ;
;;;82         }
;;;83     
;;;84     }
000044  4770              BX       lr
;;;85     
                          ENDP

000046  0000              DCW      0x0000
                  |L1.72|
                          DCD      0x01000001
                  |L1.76|
                          DCD      0x000003af

                          AREA ||i.UART_Close||, CODE, READONLY, ALIGN=1

                  UART_Close PROC
;;;95      */
;;;96     void UART_Close(UART_T *uart)
000000  2100              MOVS     r1,#0
;;;97     {
;;;98         uart->INTEN = 0ul;
000002  6041              STR      r1,[r0,#4]
;;;99     }
000004  4770              BX       lr
;;;100    
                          ENDP


                          AREA ||i.UART_DisableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_DisableFlowCtrl PROC
;;;110     */
;;;111    void UART_DisableFlowCtrl(UART_T *uart)
000000  6841              LDR      r1,[r0,#4]
;;;112    {
;;;113        uart->INTEN &= ~(UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk);
000002  2203              MOVS     r2,#3
000004  0312              LSLS     r2,r2,#12
000006  4391              BICS     r1,r1,r2
000008  6041              STR      r1,[r0,#4]
;;;114    }
00000a  4770              BX       lr
;;;115    
                          ENDP


                          AREA ||i.UART_DisableInt||, CODE, READONLY, ALIGN=1

                  UART_DisableInt PROC
;;;135     */
;;;136    void UART_DisableInt(UART_T  *uart, uint32_t u32InterruptFlag)
000000  6842              LDR      r2,[r0,#4]
;;;137    {
;;;138        /* Disable UART specified interrupt */
;;;139        UART_DISABLE_INT(uart, u32InterruptFlag);
000002  438a              BICS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
;;;140    
;;;141    }
000006  4770              BX       lr
;;;142    
                          ENDP


                          AREA ||i.UART_EnableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_EnableFlowCtrl PROC
;;;152     */
;;;153    void UART_EnableFlowCtrl(UART_T *uart)
000000  6901              LDR      r1,[r0,#0x10]
;;;154    {
;;;155        /* Set RTS pin output is low level active */
;;;156        uart->MODEM |= UART_MODEM_RTSACTLV_Msk;
000002  2201              MOVS     r2,#1
000004  0252              LSLS     r2,r2,#9
000006  4311              ORRS     r1,r1,r2
000008  6101              STR      r1,[r0,#0x10]
;;;157    
;;;158        /* Set CTS pin input is low level active */
;;;159        uart->MODEMSTS |= UART_MODEMSTS_CTSACTLV_Msk;
00000a  6941              LDR      r1,[r0,#0x14]
00000c  1052              ASRS     r2,r2,#1
00000e  4311              ORRS     r1,r1,r2
000010  6141              STR      r1,[r0,#0x14]
;;;160    
;;;161        /* Set RTS and CTS auto flow control enable */
;;;162        uart->INTEN |= UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk;
000012  6841              LDR      r1,[r0,#4]
000014  2203              MOVS     r2,#3
000016  0312              LSLS     r2,r2,#12
000018  4311              ORRS     r1,r1,r2
00001a  6041              STR      r1,[r0,#4]
;;;163    }
00001c  4770              BX       lr
;;;164    
                          ENDP


                          AREA ||i.UART_EnableInt||, CODE, READONLY, ALIGN=1

                  UART_EnableInt PROC
;;;184     */
;;;185    void UART_EnableInt(UART_T  *uart, uint32_t u32InterruptFlag)
000000  6842              LDR      r2,[r0,#4]
;;;186    {
;;;187        /* Enable UART specified interrupt */
;;;188        UART_ENABLE_INT(uart, u32InterruptFlag);
000002  430a              ORRS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
;;;189    
;;;190    }
000006  4770              BX       lr
;;;191    
                          ENDP


                          AREA ||i.UART_Open||, CODE, READONLY, ALIGN=2

                  UART_Open PROC
;;;202     */
;;;203    void UART_Open(UART_T *uart, uint32_t u32baudrate)
000000  b5f0              PUSH     {r4-r7,lr}
;;;204    {
000002  b087              SUB      sp,sp,#0x1c
000004  460f              MOV      r7,r1
000006  4604              MOV      r4,r0
;;;205        uint32_t u32UartClkSrcSel = 0ul, u32UartClkDivNum = 0ul;
000008  2500              MOVS     r5,#0
00000a  462e              MOV      r6,r5
;;;206        uint32_t u32ClkTbl[6ul] = {__HXT, 0ul, __LXT, __HIRC, 0ul, __LIRC};
00000c  2218              MOVS     r2,#0x18
00000e  4925              LDR      r1,|L7.164|
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       __aeabi_memcpy4
;;;207        uint32_t u32Baud_Div = 0ul;
;;;208    
;;;209    
;;;210        if (uart == (UART_T *)UART0)
000016  4924              LDR      r1,|L7.168|
;;;211        {
;;;212            /* Get UART clock source selection */
;;;213            u32UartClkSrcSel = ((uint32_t)(CLK->CLKSEL1 & CLK_CLKSEL1_UART0SEL_Msk)) >> CLK_CLKSEL1_UART0SEL_Pos;
000018  4824              LDR      r0,|L7.172|
00001a  428c              CMP      r4,r1                 ;210
00001c  d106              BNE      |L7.44|
00001e  6942              LDR      r2,[r0,#0x14]
;;;214            /* Get UART clock divider number */
;;;215            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART0DIV_Msk) >> CLK_CLKDIV0_UART0DIV_Pos;
000020  6a00              LDR      r0,[r0,#0x20]
;;;216        }
;;;217        else if (uart == (UART_T *)UART1)
;;;218        {
;;;219            /* Get UART clock source selection */
;;;220            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART1SEL_Msk) >> CLK_CLKSEL1_UART1SEL_Pos;
;;;221            /* Get UART clock divider number */
;;;222            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART1DIV_Msk) >> CLK_CLKDIV0_UART1DIV_Pos;
;;;223        }
;;;224    
;;;225        /* Select UART function */
;;;226        uart->FUNCSEL = UART_FUNCSEL_UART;
;;;227    
;;;228        /* Set UART line configuration */
;;;229        uart->LINE = UART_WORD_LEN_8 | UART_PARITY_NONE | UART_STOP_BIT_1;
;;;230    
;;;231        /* Set UART Rx and RTS trigger level */
;;;232        uart->FIFO &= ~(UART_FIFO_RFITL_Msk | UART_FIFO_RTSTRGLV_Msk);
;;;233    
;;;234        /* Get PCLK clock frequency if UART clock source selection is PCLK */
;;;235        if (u32UartClkSrcSel == 4ul)
;;;236        {
;;;237            /* UART Port as UART0 */
;;;238            if (uart == (UART_T *)UART0)
;;;239            {
;;;240                u32ClkTbl[u32UartClkSrcSel] =  CLK_GetPCLK0Freq();
;;;241            }
;;;242            else     /* UART Port as UART1*/
;;;243            {
;;;244                u32ClkTbl[u32UartClkSrcSel] =  CLK_GetPCLK1Freq();
;;;245            }
;;;246    
;;;247        }
;;;248    
;;;249        /* Set UART baud rate */
;;;250        if (u32baudrate != 0ul)
;;;251        {
;;;252            u32Baud_Div = UART_BAUD_MODE2_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate);
;;;253    
;;;254            if (u32Baud_Div > 0xFFFFul)
;;;255            {
;;;256                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate));
;;;257            }
;;;258            else
;;;259            {
;;;260                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
;;;261            }
;;;262        }
;;;263    }
000022  0152              LSLS     r2,r2,#5
000024  0f55              LSRS     r5,r2,#29
000026  0500              LSLS     r0,r0,#20
000028  0f06              LSRS     r6,r0,#28
00002a  e008              B        |L7.62|
                  |L7.44|
00002c  4a20              LDR      r2,|L7.176|
00002e  4294              CMP      r4,r2                 ;217
000030  d105              BNE      |L7.62|
000032  6942              LDR      r2,[r0,#0x14]         ;220
000034  6a00              LDR      r0,[r0,#0x20]         ;222
000036  0052              LSLS     r2,r2,#1
000038  0f55              LSRS     r5,r2,#29
00003a  0400              LSLS     r0,r0,#16             ;222
00003c  0f06              LSRS     r6,r0,#28             ;222
                  |L7.62|
00003e  2000              MOVS     r0,#0                 ;226
000040  6320              STR      r0,[r4,#0x30]         ;226
000042  2003              MOVS     r0,#3                 ;229
000044  60e0              STR      r0,[r4,#0xc]          ;229
000046  68a0              LDR      r0,[r4,#8]            ;232
000048  4a1a              LDR      r2,|L7.180|
00004a  4010              ANDS     r0,r0,r2              ;232
00004c  60a0              STR      r0,[r4,#8]            ;232
00004e  2d04              CMP      r5,#4                 ;235
000050  d107              BNE      |L7.98|
000052  428c              CMP      r4,r1                 ;238
000054  d102              BNE      |L7.92|
000056  f7fffffe          BL       CLK_GetPCLK0Freq
00005a  e001              B        |L7.96|
                  |L7.92|
00005c  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L7.96|
000060  9004              STR      r0,[sp,#0x10]         ;240
                  |L7.98|
000062  2f00              CMP      r7,#0                 ;250
000064  d01b              BEQ      |L7.158|
000066  00a9              LSLS     r1,r5,#2              ;252
000068  4668              MOV      r0,sp                 ;252
00006a  5840              LDR      r0,[r0,r1]            ;252
00006c  1c71              ADDS     r1,r6,#1              ;252
00006e  f7fffffe          BL       __aeabi_uidivmod
000072  4605              MOV      r5,r0                 ;252
000074  0879              LSRS     r1,r7,#1              ;252
000076  1840              ADDS     r0,r0,r1              ;252
000078  4639              MOV      r1,r7                 ;252
00007a  f7fffffe          BL       __aeabi_uidivmod
00007e  490e              LDR      r1,|L7.184|
000080  1e80              SUBS     r0,r0,#2              ;254
000082  4288              CMP      r0,r1                 ;254
000084  d907              BLS      |L7.150|
000086  00f9              LSLS     r1,r7,#3              ;256
000088  1868              ADDS     r0,r5,r1              ;256
00008a  4639              MOV      r1,r7                 ;256
00008c  f7fffffe          BL       __aeabi_uidivmod
000090  0900              LSRS     r0,r0,#4              ;256
000092  1e80              SUBS     r0,r0,#2              ;256
000094  e002              B        |L7.156|
                  |L7.150|
000096  2103              MOVS     r1,#3                 ;260
000098  0709              LSLS     r1,r1,#28             ;260
00009a  4308              ORRS     r0,r0,r1              ;260
                  |L7.156|
00009c  6260              STR      r0,[r4,#0x24]         ;260
                  |L7.158|
00009e  b007              ADD      sp,sp,#0x1c
0000a0  bdf0              POP      {r4-r7,pc}
;;;264    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L7.164|
                          DCD      ||.constdata||
                  |L7.168|
                          DCD      0x40070000
                  |L7.172|
                          DCD      0x40000200
                  |L7.176|
                          DCD      0x40071000
                  |L7.180|
                          DCD      0xfff0ff0f
                  |L7.184|
                          DCD      0x0000ffff

                          AREA ||i.UART_Read||, CODE, READONLY, ALIGN=1

                  UART_Read PROC
;;;276     */
;;;277    uint32_t UART_Read(UART_T *uart, uint8_t pu8RxBuf[], uint32_t u32ReadBytes)
000000  b5f0              PUSH     {r4-r7,lr}
;;;278    {
;;;279        uint32_t  u32Count, u32delayno;
;;;280        uint32_t  u32Exit = 0ul;
000002  2700              MOVS     r7,#0
000004  4605              MOV      r5,r0                 ;278
;;;281    
;;;282        for (u32Count = 0ul; u32Count < u32ReadBytes; u32Count++)
;;;283        {
;;;284            u32delayno = 0ul;
;;;285    
;;;286            while (uart->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk)   /* Check RX empty => failed */
;;;287            {
;;;288                u32delayno++;
;;;289    
;;;290                if (u32delayno >= 0x40000000ul)
000006  2601              MOVS     r6,#1
000008  4638              MOV      r0,r7                 ;282
00000a  07b6              LSLS     r6,r6,#30
00000c  e00c              B        |L8.40|
                  |L8.14|
00000e  2300              MOVS     r3,#0                 ;284
000010  e002              B        |L8.24|
                  |L8.18|
000012  1c5b              ADDS     r3,r3,#1              ;286
000014  42b3              CMP      r3,r6
000016  d209              BCS      |L8.44|
                  |L8.24|
000018  69ac              LDR      r4,[r5,#0x18]         ;286
00001a  0464              LSLS     r4,r4,#17             ;286
00001c  d4f9              BMI      |L8.18|
;;;291                {
;;;292                    u32Exit = 1ul;
;;;293                    break;
;;;294                }
;;;295            }
;;;296    
;;;297            if (u32Exit == 1ul)
00001e  2f00              CMP      r7,#0
000020  d104              BNE      |L8.44|
;;;298            {
;;;299                break;
;;;300            }
;;;301            else
;;;302            {
;;;303                pu8RxBuf[u32Count] = (uint8_t)uart->DAT; /* Get Data from UART RX  */
000022  682b              LDR      r3,[r5,#0]
000024  540b              STRB     r3,[r1,r0]
000026  1c40              ADDS     r0,r0,#1
                  |L8.40|
000028  4290              CMP      r0,r2                 ;282
00002a  d3f0              BCC      |L8.14|
                  |L8.44|
;;;304            }
;;;305        }
;;;306    
;;;307        return u32Count;
;;;308    
;;;309    }
00002c  bdf0              POP      {r4-r7,pc}
;;;310    
                          ENDP


                          AREA ||i.UART_SelectIrDAMode||, CODE, READONLY, ALIGN=2

                  UART_SelectIrDAMode PROC
;;;426     */
;;;427    void UART_SelectIrDAMode(UART_T *uart, uint32_t u32Buadrate, uint32_t u32Direction)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;428    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;429        uint32_t u32UartClkSrcSel = 0ul, u32UartClkDivNum = 0ul;
000006  2500              MOVS     r5,#0
000008  462e              MOV      r6,r5
;;;430        uint32_t u32ClkTbl[6ul] = {__HXT, 0ul, __LXT, __HIRC, 0ul, __LIRC};
00000a  2218              MOVS     r2,#0x18
00000c  4925              LDR      r1,|L9.164|
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       __aeabi_memcpy4
;;;431        uint32_t u32Baud_Div;
;;;432    
;;;433        /* Select IrDA function mode */
;;;434        uart->FUNCSEL = UART_FUNCSEL_IrDA;
000014  2702              MOVS     r7,#2
000016  6327              STR      r7,[r4,#0x30]
;;;435    
;;;436    
;;;437        if (uart == UART0)
000018  4923              LDR      r1,|L9.168|
;;;438        {
;;;439            /* Get UART clock source selection */
;;;440            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART0SEL_Msk) >> CLK_CLKSEL1_UART0SEL_Pos;
00001a  4824              LDR      r0,|L9.172|
00001c  428c              CMP      r4,r1                 ;437
00001e  d106              BNE      |L9.46|
000020  6942              LDR      r2,[r0,#0x14]
;;;441            /* Get UART clock divider number */
;;;442            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART0DIV_Msk) >> CLK_CLKDIV0_UART0DIV_Pos;
000022  6a00              LDR      r0,[r0,#0x20]
;;;443        }
;;;444        else if (uart == UART1)
;;;445        {
;;;446            /* Get UART clock source selection */
;;;447            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART1SEL_Msk) >> CLK_CLKSEL1_UART1SEL_Pos;
;;;448            /* Get UART clock divider number */
;;;449            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART1DIV_Msk) >> CLK_CLKDIV0_UART1DIV_Pos;
;;;450        }
;;;451    
;;;452    
;;;453        /* Get PCLK clock frequency if UART clock source selection is PCLK */
;;;454        if (u32UartClkSrcSel == 4ul)
;;;455        {
;;;456            if (uart == (UART_T *)UART0)
;;;457            {
;;;458                u32ClkTbl[u32UartClkSrcSel] =  CLK_GetPCLK0Freq();
;;;459            }
;;;460            else     /* UART Port as UART1*/
;;;461            {
;;;462                u32ClkTbl[u32UartClkSrcSel] =  CLK_GetPCLK1Freq();
;;;463            }
;;;464        }
;;;465    
;;;466    
;;;467        /* Set UART IrDA baud rate in mode 0 */
;;;468        if (u32Buadrate != 0ul)
;;;469        {
;;;470            u32Baud_Div = UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32Buadrate);
;;;471    
;;;472            if (u32Baud_Div < 0xFFFFul)
;;;473            {
;;;474                uart->BAUD = (UART_BAUD_MODE0 | u32Baud_Div);
;;;475            }
;;;476            else
;;;477            {
;;;478            }
;;;479        }
;;;480    
;;;481        /* Configure IrDA relative settings */
;;;482        if (u32Direction == UART_IRDA_RXEN)
;;;483        {
;;;484            uart->IRDA |= UART_IRDA_RXINV_Msk;     /*Rx signal is inverse*/
;;;485            uart->IRDA &= ~UART_IRDA_TXEN_Msk;
;;;486        }
;;;487        else
;;;488        {
;;;489            uart->IRDA &= ~UART_IRDA_TXINV_Msk;    /*Tx signal is not inverse*/
;;;490            uart->IRDA |= UART_IRDA_TXEN_Msk;
;;;491        }
;;;492    
;;;493    }
000024  0152              LSLS     r2,r2,#5
000026  0f55              LSRS     r5,r2,#29
000028  0500              LSLS     r0,r0,#20
00002a  0f06              LSRS     r6,r0,#28
00002c  e008              B        |L9.64|
                  |L9.46|
00002e  4a20              LDR      r2,|L9.176|
000030  4294              CMP      r4,r2                 ;444
000032  d10f              BNE      |L9.84|
000034  6942              LDR      r2,[r0,#0x14]         ;447
000036  6a00              LDR      r0,[r0,#0x20]         ;449
000038  0052              LSLS     r2,r2,#1
00003a  0f55              LSRS     r5,r2,#29
00003c  0400              LSLS     r0,r0,#16             ;449
00003e  0f06              LSRS     r6,r0,#28             ;449
                  |L9.64|
000040  2d04              CMP      r5,#4                 ;454
000042  d107              BNE      |L9.84|
000044  428c              CMP      r4,r1                 ;456
000046  d102              BNE      |L9.78|
000048  f7fffffe          BL       CLK_GetPCLK0Freq
00004c  e001              B        |L9.82|
                  |L9.78|
00004e  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L9.82|
000052  9004              STR      r0,[sp,#0x10]         ;458
                  |L9.84|
000054  9807              LDR      r0,[sp,#0x1c]         ;468
000056  2800              CMP      r0,#0                 ;468
000058  d011              BEQ      |L9.126|
00005a  00a9              LSLS     r1,r5,#2              ;470
00005c  4668              MOV      r0,sp                 ;470
00005e  5840              LDR      r0,[r0,r1]            ;470
000060  1c71              ADDS     r1,r6,#1              ;470
000062  f7fffffe          BL       __aeabi_uidivmod
000066  9907              LDR      r1,[sp,#0x1c]         ;470
000068  00c9              LSLS     r1,r1,#3              ;470
00006a  1840              ADDS     r0,r0,r1              ;470
00006c  9907              LDR      r1,[sp,#0x1c]         ;470
00006e  f7fffffe          BL       __aeabi_uidivmod
000072  0900              LSRS     r0,r0,#4              ;470
000074  490f              LDR      r1,|L9.180|
000076  1e80              SUBS     r0,r0,#2              ;472
000078  4288              CMP      r0,r1                 ;472
00007a  d200              BCS      |L9.126|
00007c  6260              STR      r0,[r4,#0x24]         ;474
                  |L9.126|
00007e  9808              LDR      r0,[sp,#0x20]         ;482
000080  2800              CMP      r0,#0                 ;482
000082  6aa0              LDR      r0,[r4,#0x28]         ;489
000084  d007              BEQ      |L9.150|
000086  2120              MOVS     r1,#0x20              ;489
000088  4388              BICS     r0,r0,r1              ;489
00008a  62a0              STR      r0,[r4,#0x28]         ;489
00008c  6aa0              LDR      r0,[r4,#0x28]         ;490
00008e  4338              ORRS     r0,r0,r7              ;490
                  |L9.144|
000090  62a0              STR      r0,[r4,#0x28]         ;485
000092  b009              ADD      sp,sp,#0x24
000094  bdf0              POP      {r4-r7,pc}
                  |L9.150|
000096  2140              MOVS     r1,#0x40              ;484
000098  4308              ORRS     r0,r0,r1              ;484
00009a  62a0              STR      r0,[r4,#0x28]         ;484
00009c  6aa0              LDR      r0,[r4,#0x28]         ;485
00009e  43b8              BICS     r0,r0,r7              ;485
0000a0  e7f6              B        |L9.144|
;;;494    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L9.164|
                          DCD      ||.constdata||+0x30
                  |L9.168|
                          DCD      0x40070000
                  |L9.172|
                          DCD      0x40000200
                  |L9.176|
                          DCD      0x40071000
                  |L9.180|
                          DCD      0x0000ffff

                          AREA ||i.UART_SelectLINMode||, CODE, READONLY, ALIGN=1

                  UART_SelectLINMode PROC
;;;533     */
;;;534    void UART_SelectLINMode(UART_T* uart, uint32_t u32Mode, uint32_t u32BreakLength)
000000  b510              PUSH     {r4,lr}
;;;535    {
;;;536        /* Select LIN function mode */
;;;537        uart->FUNCSEL = UART_FUNCSEL_LIN;
000002  2301              MOVS     r3,#1
000004  6303              STR      r3,[r0,#0x30]
;;;538    
;;;539        /* Select LIN function setting : Tx enable, Rx enable and break field length */
;;;540        uart->ALTCTL &= ~(UART_ALTCTL_LINTXEN_Msk | UART_ALTCTL_LINRXEN_Msk | UART_ALTCTL_BRKFL_Msk);
000006  6ac3              LDR      r3,[r0,#0x2c]
000008  24cf              MOVS     r4,#0xcf
00000a  43a3              BICS     r3,r3,r4
00000c  62c3              STR      r3,[r0,#0x2c]
;;;541        uart->ALTCTL |= (u32Mode | (u32BreakLength << UART_ALTCTL_BRKFL_Pos));
00000e  6ac3              LDR      r3,[r0,#0x2c]
000010  4311              ORRS     r1,r1,r2
000012  430b              ORRS     r3,r3,r1
000014  62c3              STR      r3,[r0,#0x2c]
;;;542    }
000016  bd10              POP      {r4,pc}
;;;543    
                          ENDP


                          AREA ||i.UART_SelectRS485Mode||, CODE, READONLY, ALIGN=2

                  UART_SelectRS485Mode PROC
;;;509     */
;;;510    void UART_SelectRS485Mode(UART_T *uart, uint32_t u32Mode, uint32_t u32Addr)
000000  b510              PUSH     {r4,lr}
;;;511    {
;;;512        /* Select UART RS485 function mode */
;;;513        uart->FUNCSEL = UART_FUNCSEL_RS485;
000002  2303              MOVS     r3,#3
000004  6303              STR      r3,[r0,#0x30]
;;;514    
;;;515        /* Set RS485 configuration */
;;;516        uart->ALTCTL &= ~(UART_ALTCTL_RS485NMM_Msk | UART_ALTCTL_RS485AUD_Msk | UART_ALTCTL_RS485AAD_Msk | UART_ALTCTL_ADDRMV_Msk);
000006  6ac3              LDR      r3,[r0,#0x2c]
000008  4c04              LDR      r4,|L11.28|
00000a  4023              ANDS     r3,r3,r4
00000c  62c3              STR      r3,[r0,#0x2c]
;;;517        uart->ALTCTL |= (u32Mode | (u32Addr << UART_ALTCTL_ADDRMV_Pos));
00000e  6ac3              LDR      r3,[r0,#0x2c]
000010  0612              LSLS     r2,r2,#24
000012  430a              ORRS     r2,r2,r1
000014  4313              ORRS     r3,r3,r2
000016  62c3              STR      r3,[r0,#0x2c]
;;;518    }
000018  bd10              POP      {r4,pc}
;;;519    
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      0x00fff8ff

                          AREA ||i.UART_SelectSingleWireMode||, CODE, READONLY, ALIGN=1

                  UART_SelectSingleWireMode PROC
;;;596     */
;;;597    void UART_SelectSingleWireMode(UART_T *uart)
000000  6b01              LDR      r1,[r0,#0x30]
;;;598    {
;;;599    
;;;600        /* Select UART SingleWire function mode */
;;;601        uart->FUNCSEL = ((uart->FUNCSEL & (~UART_FUNCSEL_FUNCSEL_Msk)) | UART_FUNCSEL_SINGLE_WIRE);
000002  08c9              LSRS     r1,r1,#3
000004  00c9              LSLS     r1,r1,#3
000006  1d09              ADDS     r1,r1,#4
000008  6301              STR      r1,[r0,#0x30]
;;;602    
;;;603    }
00000a  4770              BX       lr
;;;604    
                          ENDP


                          AREA ||i.UART_SetLine_Config||, CODE, READONLY, ALIGN=2

                  UART_SetLine_Config PROC
;;;337     */
;;;338    void UART_SetLine_Config(UART_T *uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits)
000000  b5ff              PUSH     {r0-r7,lr}
;;;339    {
000002  b087              SUB      sp,sp,#0x1c
000004  460f              MOV      r7,r1
000006  4604              MOV      r4,r0
;;;340        uint32_t u32UartClkSrcSel = 0ul, u32UartClkDivNum = 0ul;
000008  2500              MOVS     r5,#0
00000a  462e              MOV      r6,r5
;;;341        uint32_t u32ClkTbl[6ul] = {__HXT, 0ul, __LXT, __HIRC, 0, __LIRC};
00000c  2218              MOVS     r2,#0x18
00000e  4924              LDR      r1,|L13.160|
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       __aeabi_memcpy4
;;;342        uint32_t u32Baud_Div = 0ul;
;;;343    
;;;344    
;;;345        if (uart == (UART_T *)UART0)
000016  4923              LDR      r1,|L13.164|
;;;346        {
;;;347            /* Get UART clock source selection */
;;;348            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART0SEL_Msk) >> CLK_CLKSEL1_UART0SEL_Pos;
000018  4823              LDR      r0,|L13.168|
00001a  428c              CMP      r4,r1                 ;345
00001c  d106              BNE      |L13.44|
00001e  6942              LDR      r2,[r0,#0x14]
;;;349            /* Get UART clock divider number */
;;;350            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART0DIV_Msk) >> CLK_CLKDIV0_UART0DIV_Pos;
000020  6a00              LDR      r0,[r0,#0x20]
;;;351        }
;;;352        else if (uart == (UART_T *)UART1)
;;;353        {
;;;354            /* Get UART clock source selection */
;;;355            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART1SEL_Msk) >> CLK_CLKSEL1_UART1SEL_Pos;
;;;356            /* Get UART clock divider number */
;;;357            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART1DIV_Msk) >> CLK_CLKDIV0_UART1DIV_Pos;
;;;358        }
;;;359    
;;;360        /* Get PCLK clock frequency if UART clock source selection is PCLK */
;;;361        if (u32UartClkSrcSel == 4ul)
;;;362        {
;;;363            if (uart == (UART_T *)UART0)
;;;364            {
;;;365                u32ClkTbl[u32UartClkSrcSel] =  CLK_GetPCLK0Freq();
;;;366            }
;;;367            else     /* UART Port as UART1*/
;;;368            {
;;;369                u32ClkTbl[u32UartClkSrcSel] =  CLK_GetPCLK1Freq();
;;;370            }
;;;371        }
;;;372    
;;;373    
;;;374        /* Set UART baud rate */
;;;375        if (u32baudrate != 0ul)
;;;376        {
;;;377            u32Baud_Div = UART_BAUD_MODE2_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate);
;;;378    
;;;379            if (u32Baud_Div > 0xFFFFul)
;;;380            {
;;;381                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate));
;;;382            }
;;;383            else
;;;384            {
;;;385                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
;;;386            }
;;;387        }
;;;388    
;;;389        /* Set UART line configuration */
;;;390        uart->LINE = u32data_width | u32parity | u32stop_bits;
;;;391    }
000022  0152              LSLS     r2,r2,#5
000024  0f55              LSRS     r5,r2,#29
000026  0500              LSLS     r0,r0,#20
000028  0f06              LSRS     r6,r0,#28
00002a  e008              B        |L13.62|
                  |L13.44|
00002c  4a1f              LDR      r2,|L13.172|
00002e  4294              CMP      r4,r2                 ;352
000030  d10f              BNE      |L13.82|
000032  6942              LDR      r2,[r0,#0x14]         ;355
000034  6a00              LDR      r0,[r0,#0x20]         ;357
000036  0052              LSLS     r2,r2,#1
000038  0f55              LSRS     r5,r2,#29
00003a  0400              LSLS     r0,r0,#16             ;357
00003c  0f06              LSRS     r6,r0,#28             ;357
                  |L13.62|
00003e  2d04              CMP      r5,#4                 ;361
000040  d107              BNE      |L13.82|
000042  428c              CMP      r4,r1                 ;363
000044  d102              BNE      |L13.76|
000046  f7fffffe          BL       CLK_GetPCLK0Freq
00004a  e001              B        |L13.80|
                  |L13.76|
00004c  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L13.80|
000050  9004              STR      r0,[sp,#0x10]         ;365
                  |L13.82|
000052  2f00              CMP      r7,#0                 ;375
000054  d01b              BEQ      |L13.142|
000056  00a9              LSLS     r1,r5,#2              ;377
000058  4668              MOV      r0,sp                 ;377
00005a  5840              LDR      r0,[r0,r1]            ;377
00005c  1c71              ADDS     r1,r6,#1              ;377
00005e  f7fffffe          BL       __aeabi_uidivmod
000062  4605              MOV      r5,r0                 ;377
000064  0879              LSRS     r1,r7,#1              ;377
000066  1840              ADDS     r0,r0,r1              ;377
000068  4639              MOV      r1,r7                 ;377
00006a  f7fffffe          BL       __aeabi_uidivmod
00006e  4910              LDR      r1,|L13.176|
000070  1e80              SUBS     r0,r0,#2              ;379
000072  4288              CMP      r0,r1                 ;379
000074  d907              BLS      |L13.134|
000076  00f9              LSLS     r1,r7,#3              ;381
000078  1868              ADDS     r0,r5,r1              ;381
00007a  4639              MOV      r1,r7                 ;381
00007c  f7fffffe          BL       __aeabi_uidivmod
000080  0900              LSRS     r0,r0,#4              ;381
000082  1e80              SUBS     r0,r0,#2              ;381
000084  e002              B        |L13.140|
                  |L13.134|
000086  2103              MOVS     r1,#3                 ;385
000088  0709              LSLS     r1,r1,#28             ;385
00008a  4308              ORRS     r0,r0,r1              ;385
                  |L13.140|
00008c  6260              STR      r0,[r4,#0x24]         ;381
                  |L13.142|
00008e  990a              LDR      r1,[sp,#0x28]         ;390
000090  9809              LDR      r0,[sp,#0x24]         ;390
000092  4308              ORRS     r0,r0,r1              ;390
000094  9910              LDR      r1,[sp,#0x40]         ;390
000096  4308              ORRS     r0,r0,r1              ;390
000098  60e0              STR      r0,[r4,#0xc]          ;390
00009a  b00b              ADD      sp,sp,#0x2c
00009c  bdf0              POP      {r4-r7,pc}
;;;392    
                          ENDP

00009e  0000              DCW      0x0000
                  |L13.160|
                          DCD      ||.constdata||+0x18
                  |L13.164|
                          DCD      0x40070000
                  |L13.168|
                          DCD      0x40000200
                  |L13.172|
                          DCD      0x40071000
                  |L13.176|
                          DCD      0x0000ffff

                          AREA ||i.UART_SetTimeoutCnt||, CODE, READONLY, ALIGN=1

                  UART_SetTimeoutCnt PROC
;;;403     */
;;;404    void UART_SetTimeoutCnt(UART_T *uart, uint32_t u32TOC)
000000  6a02              LDR      r2,[r0,#0x20]
;;;405    {
;;;406        /* Set time-out interrupt comparator */
;;;407        uart->TOUT = (uart->TOUT & ~UART_TOUT_TOIC_Msk) | (u32TOC);
000002  0a12              LSRS     r2,r2,#8
000004  0212              LSLS     r2,r2,#8
000006  430a              ORRS     r2,r2,r1
000008  6202              STR      r2,[r0,#0x20]
;;;408    
;;;409        /* Set time-out counter enable */
;;;410        uart->INTEN |= UART_INTEN_TOCNTEN_Msk;
00000a  6841              LDR      r1,[r0,#4]
00000c  2201              MOVS     r2,#1
00000e  02d2              LSLS     r2,r2,#11
000010  4311              ORRS     r1,r1,r2
000012  6041              STR      r1,[r0,#4]
;;;411    }
000014  4770              BX       lr
;;;412    
                          ENDP


                          AREA ||i.UART_Write||, CODE, READONLY, ALIGN=1

                  UART_Write PROC
;;;554     */
;;;555    uint32_t UART_Write(UART_T *uart, uint8_t pu8TxBuf[], uint32_t u32WriteBytes)
000000  b5f0              PUSH     {r4-r7,lr}
;;;556    {
;;;557        uint32_t  u32Count, u32delayno;
;;;558        uint32_t  u32Exit = 0ul;
000002  2700              MOVS     r7,#0
000004  4605              MOV      r5,r0                 ;556
;;;559    
;;;560        for (u32Count = 0ul; u32Count != u32WriteBytes; u32Count++)
;;;561        {
;;;562            u32delayno = 0ul;
;;;563    
;;;564            while (uart->FIFOSTS & UART_FIFOSTS_TXFULL_Msk)   /* Check Tx Full */
;;;565            {
;;;566                u32delayno++;
;;;567    
;;;568                if (u32delayno >= 0x40000000ul)
000006  2601              MOVS     r6,#1
000008  4638              MOV      r0,r7                 ;560
00000a  07b6              LSLS     r6,r6,#30
00000c  e00c              B        |L15.40|
                  |L15.14|
00000e  2300              MOVS     r3,#0                 ;562
000010  e002              B        |L15.24|
                  |L15.18|
000012  1c5b              ADDS     r3,r3,#1              ;564
000014  42b3              CMP      r3,r6
000016  d209              BCS      |L15.44|
                  |L15.24|
000018  69ac              LDR      r4,[r5,#0x18]         ;564
00001a  0224              LSLS     r4,r4,#8              ;564
00001c  d4f9              BMI      |L15.18|
;;;569                {
;;;570                    u32Exit = 1ul;
;;;571                    break;
;;;572                }
;;;573            }
;;;574    
;;;575            if (u32Exit == 1ul)
00001e  2f00              CMP      r7,#0
000020  d104              BNE      |L15.44|
;;;576            {
;;;577                break;
;;;578            }
;;;579            else
;;;580            {
;;;581                uart->DAT = pu8TxBuf[u32Count];    /* Send UART Data from buffer */
000022  5c0b              LDRB     r3,[r1,r0]
000024  602b              STR      r3,[r5,#0]
000026  1c40              ADDS     r0,r0,#1
                  |L15.40|
000028  4290              CMP      r0,r2                 ;560
00002a  d1f0              BNE      |L15.14|
                  |L15.44|
;;;582            }
;;;583        }
;;;584    
;;;585        return u32Count;
;;;586    
;;;587    }
00002c  bdf0              POP      {r4-r7,pc}
;;;588    /**
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x02dc6c00
                          DCD      0x00000000
                          DCD      0x00009600
                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x02dc6c00
                          DCD      0x00000000
                          DCD      0x00009600
                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x02dc6c00
                          DCD      0x00000000
                          DCD      0x00009600

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REV16|
#line 464 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_uart_c_f12f5b44____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REVSH|
#line 479
|__asm___6_uart_c_f12f5b44____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
