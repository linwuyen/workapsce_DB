; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\clk.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\clk.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M0A21\Include -I..\..\..\Library\StdDriver\inc -I.\RTE\_Template -IC:\Users\cody_chen\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\cody_chen\AppData\Local\Arm\Packs\Nuvoton\NuMicro_DFP\1.3.21\Device\M0A21\Include -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -D_RTE_ --omf_browse=.\obj\clk.crf ..\..\..\Library\StdDriver\src\clk.c]
                          THUMB

                          AREA ||i.CLK_DisableCKO||, CODE, READONLY, ALIGN=2

                  CLK_DisableCKO PROC
;;;31       */
;;;32     void CLK_DisableCKO(void)
000000  4802              LDR      r0,|L1.12|
;;;33     {
;;;34         /* Disable CKO clock source */
;;;35         CLK->APBCLK0 &= (~CLK_APBCLK0_CLKOCKEN_Msk);
000002  6881              LDR      r1,[r0,#8]
000004  2240              MOVS     r2,#0x40
000006  4391              BICS     r1,r1,r2
000008  6081              STR      r1,[r0,#8]
;;;36     }
00000a  4770              BX       lr
;;;37     
                          ENDP

                  |L1.12|
                          DCD      0x40000200

                          AREA ||i.CLK_DisableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_DisableModuleClock PROC
;;;455      */
;;;456    void CLK_DisableModuleClock(uint32_t u32ModuleIdx)
000000  b50e              PUSH     {r1-r3,lr}
;;;457    {
;;;458        uint32_t u32ClkTbl[3] = {0x0, 0x4, 0x8};    /* AHBCLK/APBCLK offset on MODULE index, 0x0:AHBCLK, 0x1:APBCLK0, 0x2:APBCLK1 */
000002  4909              LDR      r1,|L2.40|
000004  c90e              LDM      r1,{r1-r3}
;;;459    
;;;460        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK + (u32ClkTbl[MODULE_APBCLK(u32ModuleIdx)]))  &= ~(1 << MODULE_IP_EN_Pos(u32ModuleIdx));
000006  9100              STR      r1,[sp,#0]
000008  9201              STR      r2,[sp,#4]
00000a  0f81              LSRS     r1,r0,#30
00000c  008a              LSLS     r2,r1,#2
00000e  9302              STR      r3,[sp,#8]
000010  4669              MOV      r1,sp
000012  588a              LDR      r2,[r1,r2]
000014  4905              LDR      r1,|L2.44|
000016  1851              ADDS     r1,r2,r1
000018  684a              LDR      r2,[r1,#4]
00001a  06c3              LSLS     r3,r0,#27
00001c  0edb              LSRS     r3,r3,#27
00001e  2001              MOVS     r0,#1
000020  4098              LSLS     r0,r0,r3
000022  4382              BICS     r2,r2,r0
000024  604a              STR      r2,[r1,#4]
;;;461    }
000026  bd0e              POP      {r1-r3,pc}
;;;462    
                          ENDP

                  |L2.40|
                          DCD      ||.constdata||+0x2c
                  |L2.44|
                          DCD      0x40000200

                          AREA ||i.CLK_DisableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_DisableSysTick PROC
;;;528      */
;;;529    void CLK_DisableSysTick(void)
000000  4901              LDR      r1,|L3.8|
;;;530    {
;;;531        /* Set System Tick counter disabled */
;;;532        SysTick->CTRL = 0;
000002  2000              MOVS     r0,#0
000004  6108              STR      r0,[r1,#0x10]
;;;533    }
000006  4770              BX       lr
;;;534    
                          ENDP

                  |L3.8|
                          DCD      0xe000e000

                          AREA ||i.CLK_DisableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_DisableXtalRC PROC
;;;391      */
;;;392    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  4902              LDR      r1,|L4.12|
;;;393    {
;;;394        CLK->PWRCTL &= ~u32ClkMask;
000002  680a              LDR      r2,[r1,#0]
000004  4382              BICS     r2,r2,r0
000006  600a              STR      r2,[r1,#0]
;;;395    }
000008  4770              BX       lr
;;;396    
                          ENDP

00000a  0000              DCW      0x0000
                  |L4.12|
                          DCD      0x40000200

                          AREA ||i.CLK_EnableCKO||, CODE, READONLY, ALIGN=2

                  CLK_EnableCKO PROC
;;;57       */
;;;58     void CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En)
000000  0152              LSLS     r2,r2,#5
;;;59     {
;;;60         /* CKO = clock source / 2^(u32ClkDiv + 1) */
;;;61         CLK->CLKOCTL = CLK_CLKOCTL_CLKOEN_Msk | u32ClkDiv | (u32ClkDivBy1En << CLK_CLKOCTL_DIV1EN_Pos);
000002  430a              ORRS     r2,r2,r1
000004  2110              MOVS     r1,#0x10
000006  430a              ORRS     r2,r2,r1
000008  4906              LDR      r1,|L5.36|
00000a  620a              STR      r2,[r1,#0x20]
;;;62     
;;;63         /* Enable CKO clock source */
;;;64         CLK->APBCLK0 |= CLK_APBCLK0_CLKOCKEN_Msk;
00000c  4905              LDR      r1,|L5.36|
00000e  3940              SUBS     r1,r1,#0x40
000010  688a              LDR      r2,[r1,#8]
000012  2340              MOVS     r3,#0x40
000014  431a              ORRS     r2,r2,r3
000016  608a              STR      r2,[r1,#8]
;;;65     
;;;66         /* Select CKO clock source */
;;;67         CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_CLKOSEL_Msk)) | (u32ClkSrc);
000018  694a              LDR      r2,[r1,#0x14]
00001a  2370              MOVS     r3,#0x70
00001c  439a              BICS     r2,r2,r3
00001e  4302              ORRS     r2,r2,r0
000020  614a              STR      r2,[r1,#0x14]
;;;68     }
000022  4770              BX       lr
;;;69     
                          ENDP

                  |L5.36|
                          DCD      0x40000240

                          AREA ||i.CLK_EnableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_EnableModuleClock PROC
;;;422      */
;;;423    void CLK_EnableModuleClock(uint32_t u32ModuleIdx)
000000  b50e              PUSH     {r1-r3,lr}
;;;424    {
;;;425        uint32_t u32ClkTbl[3] = {0x0, 0x4, 0x8};    /* AHBCLK/APBCLK offset on MODULE index, 0x0:AHBCLK, 0x1:APBCLK0, 0x2:APBCLK1 */
000002  4909              LDR      r1,|L6.40|
000004  c90e              LDM      r1,{r1-r3}
;;;426    
;;;427        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK + (u32ClkTbl[MODULE_APBCLK(u32ModuleIdx)]))  |= 1 << MODULE_IP_EN_Pos(u32ModuleIdx);
000006  9100              STR      r1,[sp,#0]
000008  9201              STR      r2,[sp,#4]
00000a  0f81              LSRS     r1,r0,#30
00000c  008a              LSLS     r2,r1,#2
00000e  9302              STR      r3,[sp,#8]
000010  4669              MOV      r1,sp
000012  588a              LDR      r2,[r1,r2]
000014  4905              LDR      r1,|L6.44|
000016  1851              ADDS     r1,r2,r1
000018  684a              LDR      r2,[r1,#4]
00001a  06c3              LSLS     r3,r0,#27
00001c  0edb              LSRS     r3,r3,#27
00001e  2001              MOVS     r0,#1
000020  4098              LSLS     r0,r0,r3
000022  4302              ORRS     r2,r2,r0
000024  604a              STR      r2,[r1,#4]
;;;428    }
000026  bd0e              POP      {r1-r3,pc}
;;;429    
                          ENDP

                  |L6.40|
                          DCD      ||.constdata||+0x20
                  |L6.44|
                          DCD      0x40000200

                          AREA ||i.CLK_EnableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_EnableSysTick PROC
;;;501      */
;;;502    void CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count)
000000  b570              PUSH     {r4-r6,lr}
;;;503    {
;;;504        /* Set System Tick counter disabled */
;;;505        SysTick->CTRL = 0;
000002  4a0b              LDR      r2,|L7.48|
000004  2400              MOVS     r4,#0
000006  6114              STR      r4,[r2,#0x10]
;;;506    
;;;507        /* Set System Tick clock source */
;;;508        if(u32ClkSrc == CLK_CLKSEL0_STCLKSEL_HCLK)
000008  2804              CMP      r0,#4
00000a  d00c              BEQ      |L7.38|
;;;509            SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
;;;510        else
;;;511            CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
00000c  4d09              LDR      r5,|L7.52|
00000e  692b              LDR      r3,[r5,#0x10]
000010  2638              MOVS     r6,#0x38
000012  43b3              BICS     r3,r3,r6
000014  4303              ORRS     r3,r3,r0
000016  612b              STR      r3,[r5,#0x10]
                  |L7.24|
;;;512    
;;;513        /* Set System Tick reload value */
;;;514        SysTick->LOAD = u32Count;
000018  6151              STR      r1,[r2,#0x14]
;;;515    
;;;516        /* Clear System Tick current value and counter flag */
;;;517        SysTick->VAL = 0;
00001a  6194              STR      r4,[r2,#0x18]
;;;518    
;;;519        /* Set System Tick interrupt enabled and counter enabled */
;;;520        SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;
00001c  6910              LDR      r0,[r2,#0x10]
00001e  2103              MOVS     r1,#3
000020  4308              ORRS     r0,r0,r1
000022  6110              STR      r0,[r2,#0x10]
;;;521    }
000024  bd70              POP      {r4-r6,pc}
                  |L7.38|
000026  6910              LDR      r0,[r2,#0x10]         ;509
000028  2304              MOVS     r3,#4                 ;509
00002a  4318              ORRS     r0,r0,r3              ;509
00002c  6110              STR      r0,[r2,#0x10]         ;509
00002e  e7f3              B        |L7.24|
;;;522    
                          ENDP

                  |L7.48|
                          DCD      0xe000e000
                  |L7.52|
                          DCD      0x40000200

                          AREA ||i.CLK_EnableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_EnableXtalRC PROC
;;;375      */
;;;376    void CLK_EnableXtalRC(uint32_t u32ClkMask)
000000  4902              LDR      r1,|L8.12|
;;;377    {
;;;378        CLK->PWRCTL |= u32ClkMask;
000002  680a              LDR      r2,[r1,#0]
000004  4302              ORRS     r2,r2,r0
000006  600a              STR      r2,[r1,#0]
;;;379    }
000008  4770              BX       lr
;;;380    
                          ENDP

00000a  0000              DCW      0x0000
                  |L8.12|
                          DCD      0x40000200

                          AREA ||i.CLK_GetCPUFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetCPUFreq PROC
;;;201      */
;;;202    uint32_t CLK_GetCPUFreq(void)
000000  b510              PUSH     {r4,lr}
;;;203    {
;;;204        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;205        return SystemCoreClock;
000006  4801              LDR      r0,|L9.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;206    }
00000a  bd10              POP      {r4,pc}
;;;207    
                          ENDP

                  |L9.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHCLKFreq PROC
;;;189      */
;;;190    uint32_t CLK_GetHCLKFreq(void)
000000  b510              PUSH     {r4,lr}
;;;191    {
;;;192        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;193        return SystemCoreClock;
000006  4801              LDR      r0,|L10.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;194    }
00000a  bd10              POP      {r4,pc}
;;;195    
                          ENDP

                  |L10.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHXTFreq PROC
;;;131      */
;;;132    uint32_t CLK_GetHXTFreq(void)
000000  4802              LDR      r0,|L11.12|
;;;133    {
;;;134        if(CLK->PWRCTL & CLK_PWRCTL_HXTEN_Msk)
000002  6800              LDR      r0,[r0,#0]
000004  07c0              LSLS     r0,r0,#31
000006  d000              BEQ      |L11.10|
;;;135            return __HXT;
000008  4801              LDR      r0,|L11.16|
                  |L11.10|
;;;136        else
;;;137            return 0;
;;;138    }
00000a  4770              BX       lr
;;;139    
                          ENDP

                  |L11.12|
                          DCD      0x40000200
                  |L11.16|
                          DCD      0x00b71b00

                          AREA ||i.CLK_GetLXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetLXTFreq PROC
;;;145      */
;;;146    uint32_t CLK_GetLXTFreq(void)
000000  4804              LDR      r0,|L12.20|
;;;147    {
;;;148        if(CLK->PWRCTL & CLK_PWRCTL_LXTEN_Msk)
000002  6800              LDR      r0,[r0,#0]
000004  0780              LSLS     r0,r0,#30
000006  d502              BPL      |L12.14|
;;;149            return __LXT;
000008  2001              MOVS     r0,#1
00000a  03c0              LSLS     r0,r0,#15
;;;150        else
;;;151            return 0;
;;;152    }
00000c  4770              BX       lr
                  |L12.14|
00000e  2000              MOVS     r0,#0                 ;151
000010  4770              BX       lr
;;;153    
                          ENDP

000012  0000              DCW      0x0000
                  |L12.20|
                          DCD      0x40000200

                          AREA ||i.CLK_GetPCLK0Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK0Freq PROC
;;;159      */
;;;160    uint32_t CLK_GetPCLK0Freq(void)
000000  b510              PUSH     {r4,lr}
;;;161    {
;;;162        uint32_t PCLK0Div;
;;;163    
;;;164        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;165        PCLK0Div = (CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) >> CLK_PCLKDIV_APB0DIV_Pos;
000006  4804              LDR      r0,|L13.24|
000008  6b40              LDR      r0,[r0,#0x34]
00000a  0741              LSLS     r1,r0,#29
;;;166        return (SystemCoreClock >> PCLK0Div);
00000c  4803              LDR      r0,|L13.28|
00000e  0f49              LSRS     r1,r1,#29             ;165
000010  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000012  40c8              LSRS     r0,r0,r1
;;;167    }
000014  bd10              POP      {r4,pc}
;;;168    
                          ENDP

000016  0000              DCW      0x0000
                  |L13.24|
                          DCD      0x40000200
                  |L13.28|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK1Freq PROC
;;;174      */
;;;175    uint32_t CLK_GetPCLK1Freq(void)
000000  b510              PUSH     {r4,lr}
;;;176    {
;;;177        uint32_t PCLK1Div;
;;;178    
;;;179        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;180        PCLK1Div = (CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) >> CLK_PCLKDIV_APB1DIV_Pos;
000006  4804              LDR      r0,|L14.24|
000008  6b40              LDR      r0,[r0,#0x34]
;;;181        return (SystemCoreClock >> PCLK1Div);
;;;182    }
00000a  0640              LSLS     r0,r0,#25
00000c  0f41              LSRS     r1,r0,#29
00000e  4803              LDR      r0,|L14.28|
000010  6800              LDR      r0,[r0,#0]            ;181  ; SystemCoreClock
000012  40c8              LSRS     r0,r0,r1              ;181
000014  bd10              POP      {r4,pc}
;;;183    
                          ENDP

000016  0000              DCW      0x0000
                  |L14.24|
                          DCD      0x40000200
                  |L14.28|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_Idle||, CODE, READONLY, ALIGN=2

                  CLK_Idle PROC
;;;113      */
;;;114    void CLK_Idle(void)
000000  4805              LDR      r0,|L15.24|
;;;115    {
;;;116        /* Set the processor uses sleep as its low power mode */
;;;117        SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
000002  6901              LDR      r1,[r0,#0x10]
000004  2204              MOVS     r2,#4
000006  4391              BICS     r1,r1,r2
000008  6101              STR      r1,[r0,#0x10]
;;;118    
;;;119        /* Set chip in idle mode because of WFI command */
;;;120        CLK->PWRCTL &= ~CLK_PWRCTL_PDEN_Msk;
00000a  4804              LDR      r0,|L15.28|
00000c  6801              LDR      r1,[r0,#0]
00000e  2280              MOVS     r2,#0x80
000010  4391              BICS     r1,r1,r2
000012  6001              STR      r1,[r0,#0]
;;;121    
;;;122        /* Chip enter idle mode after CPU run WFI instruction */
;;;123        __WFI();
000014  bf30              WFI      
;;;124    }
000016  4770              BX       lr
;;;125    
                          ENDP

                  |L15.24|
                          DCD      0xe000ed00
                  |L15.28|
                          DCD      0x40000200

                          AREA ||i.CLK_PowerDown||, CODE, READONLY, ALIGN=2

                  CLK_PowerDown PROC
;;;77       */
;;;78     void CLK_PowerDown(void)
000000  b508              PUSH     {r3,lr}
;;;79     {
;;;80         volatile uint32_t u32SysTickTICKINT = 0;    /* Backup Systick interrupt enable bit */
000002  2000              MOVS     r0,#0
;;;81     
;;;82         /* Check HIRC/MIRC auto trim function disable */
;;;83         if(SYS->HIRCTRIMCTL & SYS_HIRCTRIMCTL_FREQSEL_Msk)
000004  9000              STR      r0,[sp,#0]
000006  480f              LDR      r0,|L16.68|
000008  6b00              LDR      r0,[r0,#0x30]
00000a  0780              LSLS     r0,r0,#30
00000c  d118              BNE      |L16.64|
;;;84         {
;;;85             return;
;;;86         }
;;;87     
;;;88         /* Set the processor uses deep sleep as its low power mode */
;;;89         SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
00000e  480e              LDR      r0,|L16.72|
000010  6901              LDR      r1,[r0,#0x10]
000012  2204              MOVS     r2,#4
000014  4311              ORRS     r1,r1,r2
000016  6101              STR      r1,[r0,#0x10]
;;;90     
;;;91         /* Set system Power-down enabled */
;;;92         CLK->PWRCTL |= CLK_PWRCTL_PDEN_Msk;
000018  480c              LDR      r0,|L16.76|
00001a  6801              LDR      r1,[r0,#0]
00001c  2280              MOVS     r2,#0x80
00001e  4311              ORRS     r1,r1,r2
000020  6001              STR      r1,[r0,#0]
;;;93     
;;;94         /* Backup systick interrupt setting */
;;;95         u32SysTickTICKINT = SysTick->CTRL & SysTick_CTRL_TICKINT_Msk;
000022  480b              LDR      r0,|L16.80|
000024  6902              LDR      r2,[r0,#0x10]
000026  2102              MOVS     r1,#2
000028  400a              ANDS     r2,r2,r1
;;;96     
;;;97         /* Disable systick interrupt */
;;;98         SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
00002a  9200              STR      r2,[sp,#0]
00002c  6902              LDR      r2,[r0,#0x10]
00002e  438a              BICS     r2,r2,r1
000030  6102              STR      r2,[r0,#0x10]
;;;99     
;;;100        /* Chip enter Power-down mode after CPU run WFI instruction */
;;;101        __WFI();
000032  bf30              WFI      
;;;102    
;;;103        /* Restore systick interrupt setting */
;;;104        if(u32SysTickTICKINT) SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk;
000034  9a00              LDR      r2,[sp,#0]
000036  2a00              CMP      r2,#0
000038  d002              BEQ      |L16.64|
00003a  6902              LDR      r2,[r0,#0x10]
00003c  430a              ORRS     r2,r2,r1
00003e  6102              STR      r2,[r0,#0x10]
                  |L16.64|
;;;105    }
000040  bd08              POP      {r3,pc}
;;;106    
                          ENDP

000042  0000              DCW      0x0000
                  |L16.68|
                          DCD      0x400000c0
                  |L16.72|
                          DCD      0xe000ed00
                  |L16.76|
                          DCD      0x40000200
                  |L16.80|
                          DCD      0xe000e000

                          AREA ||i.CLK_SetCoreClock||, CODE, READONLY, ALIGN=2

                  CLK_SetCoreClock PROC
;;;215      */
;;;216    uint32_t CLK_SetCoreClock(uint32_t u32Hclk)
000000  b510              PUSH     {r4,lr}
;;;217    {
;;;218        /* Switch HCLK clock source to HIRC clock */
;;;219        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
000002  4c09              LDR      r4,|L17.40|
000004  6820              LDR      r0,[r4,#0]
000006  2104              MOVS     r1,#4
000008  4308              ORRS     r0,r0,r1
00000a  6020              STR      r0,[r4,#0]
;;;220        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00000c  2010              MOVS     r0,#0x10
00000e  f7fffffe          BL       CLK_WaitClockReady
;;;221        CLK->CLKSEL0 |= CLK_CLKSEL0_HCLKSEL_Msk;
000012  6920              LDR      r0,[r4,#0x10]
000014  2107              MOVS     r1,#7
000016  4308              ORRS     r0,r0,r1
000018  6120              STR      r0,[r4,#0x10]
;;;222        CLK->CLKDIV0 &= (~CLK_CLKDIV0_HCLKDIV_Msk);
00001a  6a20              LDR      r0,[r4,#0x20]
00001c  0900              LSRS     r0,r0,#4
00001e  0100              LSLS     r0,r0,#4
000020  6220              STR      r0,[r4,#0x20]
;;;223    
;;;224        /* Return actually HCLK frequency is HIRC frequency divide 1 */
;;;225        return (__HIRC);
000022  4802              LDR      r0,|L17.44|
;;;226    }
000024  bd10              POP      {r4,pc}
;;;227    
                          ENDP

000026  0000              DCW      0x0000
                  |L17.40|
                          DCD      0x40000200
                  |L17.44|
                          DCD      0x02dc6c00

                          AREA ||i.CLK_SetHCLK||, CODE, READONLY, ALIGN=2

                  CLK_SetHCLK PROC
;;;240      */
;;;241    void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;242    {
;;;243        uint32_t u32HIRCSTB;
;;;244    
;;;245        /* Read HIRC clock source stable flag */
;;;246        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000002  4812              LDR      r0,|L18.76|
000004  b081              SUB      sp,sp,#4              ;242
000006  6905              LDR      r5,[r0,#0x10]
000008  460f              MOV      r7,r1                 ;242
00000a  2010              MOVS     r0,#0x10
;;;247    
;;;248        /* Switch to HIRC for Safe. Avoid HCLK too high when applying new divider. */
;;;249        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00000c  4c0f              LDR      r4,|L18.76|
00000e  4005              ANDS     r5,r5,r0              ;246
000010  3c40              SUBS     r4,r4,#0x40
000012  6820              LDR      r0,[r4,#0]
000014  2604              MOVS     r6,#4
000016  4330              ORRS     r0,r0,r6
000018  6020              STR      r0,[r4,#0]
;;;250        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00001a  2010              MOVS     r0,#0x10
00001c  f7fffffe          BL       CLK_WaitClockReady
;;;251        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | CLK_CLKSEL0_HCLKSEL_HIRC;
000020  6920              LDR      r0,[r4,#0x10]
000022  2107              MOVS     r1,#7
000024  4308              ORRS     r0,r0,r1
000026  6120              STR      r0,[r4,#0x10]
;;;252    
;;;253        /* Apply new Divider */
;;;254        CLK->CLKDIV0 = (CLK->CLKDIV0 & (~CLK_CLKDIV0_HCLKDIV_Msk)) | u32ClkDiv;
000028  6a20              LDR      r0,[r4,#0x20]
00002a  0900              LSRS     r0,r0,#4
00002c  0100              LSLS     r0,r0,#4
00002e  4338              ORRS     r0,r0,r7
000030  6220              STR      r0,[r4,#0x20]
;;;255    
;;;256        /* Switch HCLK to new HCLK source */
;;;257        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | u32ClkSrc;
000032  6920              LDR      r0,[r4,#0x10]
000034  4388              BICS     r0,r0,r1
000036  9901              LDR      r1,[sp,#4]
000038  4308              ORRS     r0,r0,r1
00003a  6120              STR      r0,[r4,#0x10]
;;;258    
;;;259        /* Update System Core Clock */
;;;260        SystemCoreClockUpdate();
00003c  f7fffffe          BL       SystemCoreClockUpdate
;;;261    
;;;262        /* Disable HIRC if HIRC is disabled before switching HCLK source */
;;;263        if(u32HIRCSTB == 0)
000040  2d00              CMP      r5,#0
000042  d102              BNE      |L18.74|
;;;264            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000044  6820              LDR      r0,[r4,#0]
000046  43b0              BICS     r0,r0,r6
000048  6020              STR      r0,[r4,#0]
                  |L18.74|
;;;265    }
00004a  bdfe              POP      {r1-r7,pc}
;;;266    
                          ENDP

                  |L18.76|
                          DCD      0x40000240

                          AREA ||i.CLK_SetModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_SetModuleClock PROC
;;;324      */
;;;325    void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b5f0              PUSH     {r4-r7,lr}
;;;326    {
;;;327        uint32_t u32sel = 0, u32div = 0;
;;;328        uint32_t u32SelTbl[4] = {0x0, 0x4, 0x8, 0xC};   /* CLKSEL offset on MODULE index, 0x0:CLKSEL0, 0x1:CLKSEL1, 0x2:CLKSEL2, 0x3:CLKSEL3 */
000002  4b19              LDR      r3,|L19.104|
000004  b088              SUB      sp,sp,#0x20           ;326
000006  cbf0              LDM      r3!,{r4-r7}
000008  9400              STR      r4,[sp,#0]
00000a  ac01              ADD      r4,sp,#4
00000c  c4e0              STM      r4!,{r5-r7}
00000e  cb78              LDM      r3,{r3-r6}
000010  af04              ADD      r7,sp,#0x10
000012  c778              STM      r7!,{r3-r6}
;;;329        uint32_t u32DivTbl[4] = {0x0, 0x0, 0x0, 0x10};  /* CLKDIV offset on MODULE index, 0x0:CLKDIV0, 0x1:CLKDIV1, 0x2:CLKDIV3, 0x3:CLKDIV4 */
;;;330    
;;;331        if(MODULE_CLKDIV_Msk(u32ModuleIdx) != MODULE_NoMsk)
000014  0a84              LSRS     r4,r0,#10
000016  0623              LSLS     r3,r4,#24
000018  0e1b              LSRS     r3,r3,#24
00001a  d00e              BEQ      |L19.58|
;;;332        {
;;;333            /* Get clock divider control register address */
;;;334            u32div = (uint32_t)&CLK->CLKDIV0 + (u32DivTbl[MODULE_CLKDIV(u32ModuleIdx)]);
00001c  0303              LSLS     r3,r0,#12
00001e  0f9b              LSRS     r3,r3,#30
000020  009b              LSLS     r3,r3,#2
000022  ad04              ADD      r5,sp,#0x10
000024  58eb              LDR      r3,[r5,r3]
000026  4d11              LDR      r5,|L19.108|
000028  195b              ADDS     r3,r3,r5
;;;335            /* Apply new divider */
;;;336            M32(u32div) = (M32(u32div) & (~(MODULE_CLKDIV_Msk(u32ModuleIdx) << MODULE_CLKDIV_Pos(u32ModuleIdx)))) | u32ClkDiv;
00002a  b2e5              UXTB     r5,r4
00002c  0584              LSLS     r4,r0,#22
00002e  0ee4              LSRS     r4,r4,#27
000030  40a5              LSLS     r5,r5,r4
000032  681c              LDR      r4,[r3,#0]
000034  43ac              BICS     r4,r4,r5
000036  4314              ORRS     r4,r4,r2
000038  601c              STR      r4,[r3,#0]
                  |L19.58|
;;;337        }
;;;338    
;;;339        if(MODULE_CLKSEL_Msk(u32ModuleIdx) != MODULE_NoMsk)
00003a  0e42              LSRS     r2,r0,#25
00003c  0752              LSLS     r2,r2,#29
00003e  d010              BEQ      |L19.98|
;;;340        {
;;;341            /* Get clock select control register address */
;;;342            u32sel = (uint32_t)&CLK->CLKSEL0 + (u32SelTbl[MODULE_CLKSEL(u32ModuleIdx)]);
000040  0082              LSLS     r2,r0,#2
000042  0f92              LSRS     r2,r2,#30
000044  0092              LSLS     r2,r2,#2
000046  466b              MOV      r3,sp
000048  589a              LDR      r2,[r3,r2]
00004a  4b08              LDR      r3,|L19.108|
00004c  3b10              SUBS     r3,r3,#0x10
00004e  18d2              ADDS     r2,r2,r3
;;;343            /* Set new clock selection setting */
;;;344            M32(u32sel) = (M32(u32sel) & (~(MODULE_CLKSEL_Msk(u32ModuleIdx) << MODULE_CLKSEL_Pos(u32ModuleIdx)))) | u32ClkSrc;
000050  0103              LSLS     r3,r0,#4
000052  0f5b              LSRS     r3,r3,#29
000054  01c0              LSLS     r0,r0,#7
000056  0ec0              LSRS     r0,r0,#27
000058  4083              LSLS     r3,r3,r0
00005a  6810              LDR      r0,[r2,#0]
00005c  4398              BICS     r0,r0,r3
00005e  4308              ORRS     r0,r0,r1
000060  6010              STR      r0,[r2,#0]
                  |L19.98|
;;;345        }
;;;346    }
000062  b008              ADD      sp,sp,#0x20
000064  bdf0              POP      {r4-r7,pc}
;;;347    
                          ENDP

000066  0000              DCW      0x0000
                  |L19.104|
                          DCD      ||.constdata||
                  |L19.108|
                          DCD      0x40000220

                          AREA ||i.CLK_SetSysTickClockSrc||, CODE, READONLY, ALIGN=2

                  CLK_SetSysTickClockSrc PROC
;;;359      */
;;;360    void CLK_SetSysTickClockSrc(uint32_t u32ClkSrc)
000000  4a03              LDR      r2,|L20.16|
;;;361    {
;;;362        CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
000002  6911              LDR      r1,[r2,#0x10]
000004  2338              MOVS     r3,#0x38
000006  4399              BICS     r1,r1,r3
000008  4301              ORRS     r1,r1,r0
00000a  6111              STR      r1,[r2,#0x10]
;;;363    }
00000c  4770              BX       lr
;;;364    
                          ENDP

00000e  0000              DCW      0x0000
                  |L20.16|
                          DCD      0x40000200

                          AREA ||i.CLK_WaitClockReady||, CODE, READONLY, ALIGN=2

                  CLK_WaitClockReady PROC
;;;474      */
;;;475    uint32_t CLK_WaitClockReady(uint32_t u32ClkMask)
000000  b510              PUSH     {r4,lr}
;;;476    {
000002  4604              MOV      r4,r0
;;;477        int32_t i32TimeOutCnt = 2160000;
000004  4907              LDR      r1,|L21.36|
;;;478    
;;;479        while((CLK->STATUS & u32ClkMask) != u32ClkMask)
000006  4b08              LDR      r3,|L21.40|
000008  e005              B        |L21.22|
                  |L21.10|
;;;480        {
;;;481            if(i32TimeOutCnt-- <= 0)
00000a  460a              MOV      r2,r1
00000c  1e49              SUBS     r1,r1,#1
00000e  2a00              CMP      r2,#0
000010  dc01              BGT      |L21.22|
;;;482                return 0;
000012  2000              MOVS     r0,#0
;;;483        }
;;;484    
;;;485        return 1;
;;;486    }
000014  bd10              POP      {r4,pc}
                  |L21.22|
000016  691a              LDR      r2,[r3,#0x10]         ;479
000018  4620              MOV      r0,r4                 ;479
00001a  4390              BICS     r0,r0,r2              ;479
00001c  d1f5              BNE      |L21.10|
00001e  2001              MOVS     r0,#1                 ;485
000020  bd10              POP      {r4,pc}
;;;487    
                          ENDP

000022  0000              DCW      0x0000
                  |L21.36|
                          DCD      0x0020f580
                  |L21.40|
                          DCD      0x40000240

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x0000000c
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000010
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000008

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REV16|
#line 464 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_clk_c_9b5832dc____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REVSH|
#line 479
|__asm___5_clk_c_9b5832dc____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
